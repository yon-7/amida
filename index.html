<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚ã¿ã ãã˜ã‚¢ãƒ—ãƒª</title>
    
    <!-- ã‚¢ã‚¤ã‚³ãƒ³è¨­å®š -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 fill=%22%23007bff%22 rx=%2212%22/><path d=%22M18 12v40M32 12v40M46 12v40M18 24h14M32 36h14M18 48h14%22 stroke=%22white%22 stroke-width=%224%22 stroke-linecap=%22round%22/></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 fill=%22%23007bff%22 rx=%2212%22/><path d=%22M18 12v40M32 12v40M46 12v40M18 24h14M32 36h14M18 48h14%22 stroke=%22white%22 stroke-width=%224%22 stroke-linecap=%22round%22/></svg>">

    <style>
        /* CSS */
        body { font-family: "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif; text-align: center; background-color: #fdfdfd; color: #333; margin: 0; padding: 20px; }
        h1 { margin: 10px 0 25px 0; font-size: 24px; font-weight: bold; }
        
        /* ã‚³ãƒ³ãƒ†ãƒŠ */
        #setup-area, #game-area { 
            margin: 0 auto; max-width: 600px; background: white; padding: 30px 25px; 
            border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 1px solid #eee; 
        }
        .hidden { display: none; }
        
        /* è¨­å®šé …ç›®ãƒ©ãƒ™ãƒ« */
        label.section-title { font-weight: bold; display: block; margin-top: 25px; text-align: left; margin-left: 5%; font-size: 16px; }
        label.section-title:first-child { margin-top: 0; }
        
        /* è£œè¶³ãƒ†ã‚­ã‚¹ãƒˆã‚µã‚¤ã‚º */
        .small-size { font-size: 0.85em; font-weight: normal; color: #666; }

        /* ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ */
        label.radio-option { display: inline-block; font-weight: normal; margin-right: 15px; cursor: pointer; margin-top: 8px; }

        /* å…¥åŠ›è¦ç´  */
        input[type="number"] { padding: 10px; width: 80px; text-align: center; font-size: 18px; border: 1px solid #ccc; border-radius: 6px; }
        textarea { width: 90%; height: 100px; padding: 12px; margin: 10px 0; border: 1px solid #ccc; border-radius: 6px; font-size: 16px; resize: vertical; }
        
        /* ãƒœã‚¿ãƒ³ */
        button { 
            padding: 12px 24px; background-color: #333; color: white; border: none; border-radius: 6px; 
            cursor: pointer; font-size: 16px; margin: 10px 5px; font-weight: bold; transition: opacity 0.2s;
        }
        button:hover { opacity: 0.8; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 1; }
        
        button.shuffle-btn { background-color: #ff9800; font-size: 14px; padding: 8px 16px; } 
        button.secondary { background-color: #999; }
        
        #btn-lock { background-color: #28a745; min-width: 180px; }
        #btn-lock.locked { background-color: #dc3545; }

        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ */
        #canvas-container { position: relative; margin: 20px auto; width: 600px; max-width: 100%; overflow-x: auto; }
        canvas { touch-action: none; cursor: pointer; background: #fff; display: block; margin: 0 auto; }
        canvas.locked { cursor: default; }

        /* åå‰å…¥åŠ› */
        .name-input {
            position: absolute; top: 10px; width: 50px; padding: 4px; font-size: 12px; 
            text-align: center; border: 1px solid #ccc; border-radius: 4px; background: #fff;
        }
        .name-input::placeholder { color: #ccc; }

        /* ãƒ’ãƒ³ãƒˆ */
        .hint { font-size: 0.9em; color: #555; margin-bottom: 20px; background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: left; line-height: 1.6; }
    </style>
</head>
<body>

    <h1>ã‚ã¿ã ãã˜</h1>

    <!-- è¨­å®šç”»é¢ -->
    <div id="setup-area">
        <label class="section-title">å‚åŠ äººæ•° <span class="small-size">(2ã€œ10äºº)</span></label>
        <div style="text-align: left; margin-left: 5%; margin-top: 5px;">
            <input type="number" id="num-participants" value="4" min="2" max="10"> äºº
        </div>

        <label class="section-title">çµæœã®è¨­å®š</label>
        <div style="text-align: left; margin-left: 5%;">
            <label class="radio-option">
                <input type="radio" name="resultMode" value="count" checked onclick="toggleMode('count')">
                ã‚ãŸã‚Šã®æ•°ã‚’é¸ã¶
            </label>
            <label class="radio-option">
                <input type="radio" name="resultMode" value="custom" onclick="toggleMode('custom')">
                ã‚«ã‚¹ã‚¿ãƒ ï¼ˆè‡ªç”±å…¥åŠ›ï¼‰
            </label>
        </div>

        <!-- ãƒ¢ãƒ¼ãƒ‰: ã‚ãŸã‚Šã®æ•° -->
        <div id="input-mode-count" style="text-align: left; margin-left: 5%;">
            <br>ã‚ãŸã‚Šã®æ•°: <input type="number" id="num-winners" value="1" min="1" max="10"> æœ¬<br>
            <small style="color:#666;">â€»æ®‹ã‚Šã¯è‡ªå‹•çš„ã«ã€Œã¯ãšã‚Œã€ã«ãªã‚Šã¾ã™</small>
        </div>

        <!-- ãƒ¢ãƒ¼ãƒ‰: ã‚«ã‚¹ã‚¿ãƒ  -->
        <div id="input-mode-custom" class="hidden">
            <textarea id="result-options" placeholder="ã‚ãŸã‚Š&#13;&#10;ã¯ãšã‚Œ&#13;&#10;..." onfocus="this.placeholder=''" onblur="if(this.value=='')this.placeholder='ã‚ãŸã‚Š\nã¯ãšã‚Œ\n...'"></textarea><br>
            <button class="shuffle-btn" onclick="shuffleInput()">ğŸ”€ å†…å®¹ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«</button><br>
            <small style="color:#666; display:inline-block; margin-top:5px; text-align:left;">
                â€»æ”¹è¡ŒåŒºåˆ‡ã‚Šã§å…¥åŠ›ã—ã¦ãã ã•ã„<br>
                â€»äººæ•°åˆ†ã«è¶³ã‚Šãªã„å ´åˆã¯ç©ºæ¬„ã«ãªã‚Šã¾ã™
            </small>
        </div>

        <br><br>
        <button onclick="initGame()" style="width: 100%; max-width: 300px; background-color: #007bff;">ä½œæˆã™ã‚‹</button>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
    <div id="game-area" class="hidden">
        <p class="hint">
            âœï¸ æ ã«<b>åå‰ã‚’å…¥åŠ›</b>ã€€ğŸ‘† <b>ç·šã¨ç·šã®é–“</b>ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ¨ªæ£’è¿½åŠ <br>
            ğŸ”’ å…¨å“¡æ›¸ã„ãŸã‚‰<b>ãƒ­ãƒƒã‚¯</b>ã€€ğŸ”¢ <b>ä¸¸</b>ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ
        </p>
        
        <div id="canvas-container">
            <div id="name-inputs-layer"></div>
            <canvas id="amidaCanvas" width="600" height="550"></canvas>
        </div>
        
        <div style="margin-top: 20px;">
            <button id="btn-lock" onclick="toggleLock()">ğŸ”“ ç·šã‚’ãƒ­ãƒƒã‚¯</button>
            <button id="btn-reset" class="secondary" onclick="resetLines()">ç·šã‚’æ¶ˆã™</button>
            <button class="secondary" onclick="showSetup()">è¨­å®šã«æˆ»ã‚‹</button>
        </div>
    </div>

    <script>
        // --- å¤‰æ•°å®šç¾© ---
        const canvas = document.getElementById('amidaCanvas');
        const ctx = canvas.getContext('2d');
        const inputsLayer = document.getElementById('name-inputs-layer');
        
        const MARGIN_TOP = 100;
        const START_BTN_Y = 75; 
        const MARGIN_BOTTOM = 80;
        
        let participants = 4;
        let results = [];
        let horizontalLines = []; 
        let columnWidth = 0;
        let isAnimating = false;
        let isLocked = false; 
        let animationPath = []; 
        let currentPathIndex = 0; 
        let animX = 0, animY = 0; 
        let revealed = [];

        // --- è¨­å®šç”»é¢å‡¦ç† ---
        function toggleMode(mode) {
            if (mode === 'count') {
                document.getElementById('input-mode-count').classList.remove('hidden');
                document.getElementById('input-mode-custom').classList.add('hidden');
            } else {
                document.getElementById('input-mode-count').classList.add('hidden');
                document.getElementById('input-mode-custom').classList.remove('hidden');
            }
        }

        function shuffleInput() {
            const ta = document.getElementById('result-options');
            if (!ta.value.trim()) return;
            let lines = ta.value.split('\n').map(s => s.trim()).filter(s => s !== '');
            for (let i = lines.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [lines[i], lines[j]] = [lines[j], lines[i]];
            }
            ta.value = lines.join('\n');
        }

        // --- ã‚²ãƒ¼ãƒ åˆæœŸåŒ– ---
        function initGame() {
            participants = parseInt(document.getElementById('num-participants').value);
            if (participants < 2) participants = 2;
            if (participants > 10) participants = 10;

            results = [];
            const mode = document.querySelector('input[name="resultMode"]:checked').value;

            if (mode === 'count') {
                const winCount = parseInt(document.getElementById('num-winners').value);
                for(let i=0; i<participants; i++) {
                    results.push(i < winCount ? "ã‚ãŸã‚Š" : "ã¯ãšã‚Œ");
                }
                for (let i = results.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [results[i], results[j]] = [results[j], results[i]];
                }
            } else {
                const raw = document.getElementById('result-options').value.split('\n').map(s => s.trim()).filter(s => s !== '');
                for (let i = 0; i < participants; i++) {
                    results.push(raw[i] || "");
                }
            }

            isLocked = false;
            updateLockUI();
            document.getElementById('setup-area').classList.add('hidden');
            document.getElementById('game-area').classList.remove('hidden');

            columnWidth = canvas.width / (participants + 1);
            generateNameInputs();
            resetLines();
        }

        function showSetup() {
            document.getElementById('setup-area').classList.remove('hidden');
            document.getElementById('game-area').classList.add('hidden');
        }

        // --- ãƒ­ãƒƒã‚¯æ©Ÿèƒ½ ---
        function toggleLock() {
            if (isLocked) return;
            if (confirm('ç·šã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã™ã‹ï¼Ÿ\nã“ã‚Œä»¥é™ã€ç·šã®è¿½åŠ ãƒ»å‰Šé™¤ã¯ã§ãã¾ã›ã‚“ã€‚')) {
                isLocked = true;
                updateLockUI();
            }
        }

        function updateLockUI() {
            const btnLock = document.getElementById('btn-lock');
            const btnReset = document.getElementById('btn-reset');
            if (isLocked) {
                btnLock.innerText = "ğŸ”’ ãƒ­ãƒƒã‚¯ä¸­";
                btnLock.classList.add('locked');
                btnLock.disabled = true;
                btnReset.disabled = true;
                canvas.classList.add('locked');
            } else {
                btnLock.innerText = "ğŸ”“ ç·šã‚’ãƒ­ãƒƒã‚¯";
                btnLock.classList.remove('locked');
                btnLock.disabled = false;
                btnReset.disabled = false;
                canvas.classList.remove('locked');
            }
        }

        // --- ã‚ã¿ã ãã˜å‡¦ç† ---
        function resetLines() {
            if (isLocked) return;
            horizontalLines = [];
            animationPath = []; 
            revealed = new Array(participants).fill(false);
            isAnimating = false;
            draw();
        }

        function generateNameInputs() {
            inputsLayer.innerHTML = '';
            for (let i = 0; i < participants; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'name-input';
                input.placeholder = "ãªã¾ãˆ";
                input.style.width = '54px';
                input.style.left = ((i + 1) * columnWidth - 27 - 4) + 'px'; 
                input.style.top = '10px'; 
                inputsLayer.appendChild(input);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.textAlign = 'center';
            
            for (let i = 0; i < participants; i++) {
                const x = (i + 1) * columnWidth;
                
                // ä¸¸ã¨ç•ªå·
                ctx.beginPath();
                ctx.arc(x, START_BTN_Y, 15, 0, Math.PI * 2);
                ctx.fillStyle = 'white'; ctx.fill();
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = '#333'; ctx.font = 'bold 16px Arial'; ctx.textBaseline = 'middle';
                ctx.fillText(i + 1, x, START_BTN_Y + 1);

                // ç¸¦ç·š
                ctx.strokeStyle = '#333'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(x, MARGIN_TOP); ctx.lineTo(x, canvas.height - MARGIN_BOTTOM); ctx.stroke();

                // çµæœ
                const boxX = x - 25, boxY = canvas.height - 55;
                if (revealed[i]) {
                    if (results[i]) {
                        ctx.fillStyle = '#333'; ctx.font = 'bold 16px Arial';
                        if (results[i].length > 4) ctx.font = 'bold 12px Arial';
                        ctx.fillText(results[i], x, boxY + 20);
                    }
                } else {
                    ctx.fillStyle = 'black'; ctx.fillRect(boxX, boxY, 50, 40);
                }
            }

            // æ¨ªç·š
            ctx.lineWidth = 3; ctx.strokeStyle = '#333';
            horizontalLines.forEach(l => {
                const x1 = (l.col + 1) * columnWidth, x2 = (l.col + 2) * columnWidth;
                ctx.beginPath(); ctx.moveTo(x1, l.y); ctx.lineTo(x2, l.y); ctx.stroke();
            });

            // ã‚¢ãƒ‹ãƒ¡
            if (animationPath.length > 0) {
                ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(animationPath[0].x, animationPath[0].y);
                const limit = isAnimating ? currentPathIndex : animationPath.length - 1;
                for(let k=1; k <= limit; k++) ctx.lineTo(animationPath[k].x, animationPath[k].y);
                if (isAnimating) ctx.lineTo(animX, animY);
                ctx.stroke();
            }
        }

        // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('mousedown', handleClick);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            canvas.dispatchEvent(new MouseEvent("mousedown", { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }));
        }, {passive: false});

        function handleClick(e) {
            if (isAnimating) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // ã‚¹ã‚¿ãƒ¼ãƒˆåˆ¤å®š
            if (y < MARGIN_TOP) {
                if (y > 40) { 
                    for (let i = 0; i < participants; i++) {
                        if (Math.abs(x - (i + 1) * columnWidth) < 30) {
                            startAnimation(i); return;
                        }
                    }
                }
                return;
            }
            
            // æ¨ªæ£’è¿½åŠ 
            if (isLocked) return;
            if (y > MARGIN_TOP && y < canvas.height - MARGIN_BOTTOM) {
                const col = Math.floor(x / columnWidth) - 1;
                if (col >= 0 && col < participants - 1) {
                    if (!horizontalLines.some(l => l.col === col && Math.abs(l.y - y) < 15)) {
                        horizontalLines.push({ col: col, y: y });
                        draw();
                    }
                }
            }
        }

        function startAnimation(startIdx) {
            animationPath = [];
            let cCol = startIdx, cY = MARGIN_TOP;
            animationPath.push({x: (cCol + 1) * columnWidth, y: cY});

            for(let i=0; i<2000; i++) {
                let next = horizontalLines
                    .filter(l => l.y > cY && (l.col === cCol || l.col === cCol - 1))
                    .sort((a,b) => a.y - b.y)[0];
                if (!next) {
                    cY = canvas.height - MARGIN_BOTTOM;
                    animationPath.push({x: (cCol + 1) * columnWidth, y: cY});
                    break;
                }
                cY = next.y;
                animationPath.push({x: (cCol + 1) * columnWidth, y: cY});
                cCol = (next.col === cCol) ? cCol + 1 : cCol - 1;
                animationPath.push({x: (cCol + 1) * columnWidth, y: cY});
            }
            isAnimating = true; currentPathIndex = 0;
            animX = animationPath[0].x; animY = animationPath[0].y;
            requestAnimationFrame(animateFrame);
        }

        function animateFrame() {
            const target = animationPath[currentPathIndex + 1];
            if (!target) {
                isAnimating = false;
                const finalCol = Math.round(animationPath[animationPath.length - 1].x / columnWidth) - 1;
                revealed[finalCol] = true;
                draw();
                return;
            }
            const speed = 6;
            if (animX < target.x) animX = Math.min(animX + speed, target.x);
            else if (animX > target.x) animX = Math.max(animX - speed, target.x);
            if (animY < target.y) animY = Math.min(animY + speed, target.y);
            if (animX === target.x && animY === target.y) currentPathIndex++;
            draw();
            if(isAnimating) requestAnimationFrame(animateFrame);
        }
    </script>
</body>
</html>
