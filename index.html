<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã‚ã¿ã ãã˜</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 fill=%22%23007bff%22 rx=%2212%22/><path d=%22M18 12v40M32 12v40M46 12v40M18 24h14M32 36h14M18 48h14%22 stroke=%22white%22 stroke-width=%224%22 stroke-linecap=%22round%22/></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 fill=%22%23007bff%22 rx=%2212%22/><path d=%22M18 12v40M32 12v40M46 12v40M18 24h14M32 36h14M18 48h14%22 stroke=%22white%22 stroke-width=%224%22 stroke-linecap=%22round%22/></svg>">

    <style>
        body { 
            font-family: "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif; 
            text-align: center; 
            background-color: #fdfdfd; 
            color: #333; 
            margin: 0; 
            padding: 10px; 
        }
        h1 { margin: 5px 0 15px 0; font-size: 20px; font-weight: bold; }
        
        #setup-area, #game-area { 
            margin: 0 auto; width: 100%; max-width: 600px; 
            background: white; padding: 15px; border-radius: 12px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); border: 1px solid #eee; 
            box-sizing: border-box; 
        }
        .hidden { display: none; }
        
        label.section-title { font-weight: bold; display: block; margin-top: 20px; text-align: left; margin-left: 2%; font-size: 15px; }
        label.section-title:first-child { margin-top: 0; }
        
        .small-size { font-size: 0.85em; font-weight: normal; color: #666; }

        label.radio-option { display: block; font-weight: normal; margin-bottom: 8px; cursor: pointer; font-size: 14px; }
        @media (min-width: 400px) {
            label.radio-option { display: inline-block; margin-right: 15px; margin-bottom: 0; }
        }

        input[type="number"] { padding: 8px; width: 60px; text-align: center; font-size: 16px; border: 1px solid #ccc; border-radius: 6px; }
        textarea { width: 95%; height: 80px; padding: 10px; margin: 5px 0; border: 1px solid #ccc; border-radius: 6px; font-size: 15px; resize: vertical; }
        
        button { 
            padding: 10px 15px; background-color: #333; color: white; border: none; border-radius: 6px; 
            cursor: pointer; font-size: 14px; margin: 5px 2px; font-weight: bold; transition: opacity 0.2s;
            min-height: 44px; 
        }
        button:hover { opacity: 0.8; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 1; }
        
        button.shuffle-btn { background-color: #ff9800; font-size: 13px; padding: 6px 12px; min-height: 35px; } 
        button.secondary { background-color: #999; }
        
        .button-row {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }
        .button-row button {
            flex: 1; 
            max-width: 150px;
        }
        
        #btn-undo { font-size: 20px; line-height: 1; }

        .hint-container {
            background: #f8f9fa; padding: 10px; border-radius: 8px; 
            margin-bottom: 5px; text-align: left;
        }
        .hint-item { display: flex; align-items: center; font-size: 13px; color: #555; margin-bottom: 4px; line-height: 1.4; }
        .hint-icon { font-size: 16px; margin-right: 8px; min-width: 20px; text-align: center; }

        #canvas-container { 
            position: relative; 
            margin: 30px auto 10px auto; 
            width: 100%; 
        }
        canvas { 
            touch-action: none; cursor: pointer; background: #fff; 
            display: block; margin: 0 auto; max-width: 100%;
        }
        canvas.locked { cursor: default; }

        .name-input {
            position: absolute; 
            top: -22px; 
            padding: 2px; font-size: 11px; 
            text-align: center; border: 1px solid #ccc; border-radius: 4px; background: #fff;
            height: 20px; z-index: 10;
        }
        .name-input::placeholder { color: #ccc; }
        
        .setup-indent { text-align: left; margin-left: 2%; }
        .note-text { color:#666; display:inline-block; margin-top:5px; text-align:left; line-height: 1.4; font-size: 0.85em; }
    </style>
</head>
<body>

    <h1>ã‚ã¿ã ãã˜</h1>

    <div id="setup-area">
        <label class="section-title">å‚åŠ äººæ•° <span class="small-size">(2ã€œ10äºº)</span></label>
        <div class="setup-indent" style="margin-top: 5px;">
            <input type="number" id="num-participants" value="4" min="2" max="10"> äºº
        </div>

        <label class="section-title">çµæœ</label>
        <div class="setup-indent" style="margin-top: 10px;">
            <label class="radio-option">
                <input type="radio" name="resultMode" value="count" checked onclick="toggleMode('count')">
                ã‚ãŸã‚Šã®æ•°ã‚’é¸ã¶
            </label>
            <label class="radio-option">
                <input type="radio" name="resultMode" value="custom" onclick="toggleMode('custom')">
                ã‚«ã‚¹ã‚¿ãƒ ï¼ˆè‡ªç”±å…¥åŠ›ï¼‰
            </label>
        </div>

        <div id="input-mode-count" class="setup-indent">
            <br>ã‚ãŸã‚Šã®æ•°: <input type="number" id="num-winners" value="1" min="1" max="10"> æœ¬<br>
            <small class="note-text">â€»æ®‹ã‚Šã¯è‡ªå‹•çš„ã«ã€Œã¯ãšã‚Œã€ã«ãªã‚Šã¾ã™</small>
        </div>

        <div id="input-mode-custom" class="hidden setup-indent">
            <textarea id="result-options" placeholder="ã‚ãŸã‚Š&#13;&#10;ã¯ãšã‚Œ&#13;&#10;..." onfocus="this.placeholder=''" onblur="if(this.value=='')this.placeholder='ã‚ãŸã‚Š\nã¯ãšã‚Œ\n...'"></textarea><br>
            <button class="shuffle-btn" onclick="shuffleInput()">ğŸ”€ å†…å®¹ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«</button><br>
            <small class="note-text">
                â€»æ”¹è¡ŒåŒºåˆ‡ã‚Šã§å…¥åŠ›ã—ã¦ãã ã•ã„<br>
                â€»äººæ•°åˆ†ã«è¶³ã‚Šãªã„å ´åˆã¯ç©ºæ¬„ã«ãªã‚Šã¾ã™
            </small>
        </div>

        <br><br>
        <button onclick="initGame()" style="width: 100%; max-width: 300px; background-color: #007bff;">ä½œæˆã™ã‚‹</button>
    </div>

    <div id="game-area" class="hidden">
        <div class="hint-container">
            <div class="hint-item"><span class="hint-icon">âœï¸</span><span>ãˆã‚‰ã‚“ã§<b>ãªã¾ãˆ</b>ã‚’å…¥åŠ›</span></div>
            <div class="hint-item"><span class="hint-icon">ğŸ‘†</span><span>ã‚ã„ã ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦<b>ã‚ˆã“ç·š</b>ã‚’è¿½åŠ </span></div>
            <div class="hint-item"><span class="hint-icon">ğŸ”¢</span><span>ãƒã‚±ãƒƒãƒˆã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦<b>é–‹å§‹</b></span></div>
        </div>
        
        <div id="canvas-container">
            <div id="name-inputs-layer"></div>
            <canvas id="amidaCanvas"></canvas>
        </div>
        
        <div class="button-row">
            <button id="btn-undo" class="secondary" onclick="undoLine()">â†©</button>
            <button class="secondary" onclick="showSetup()">ã‚„ã‚Šç›´ã™</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('amidaCanvas');
        const ctx = canvas.getContext('2d');
        const inputsLayer = document.getElementById('name-inputs-layer');
        const gameArea = document.getElementById('game-area');
        
        let MARGIN_TOP = 60;
        let START_BTN_Y = 25; 
        let MARGIN_BOTTOM = 60;
        
        let participants = 4;
        let results = [];
        let horizontalLines = []; 
        let columnWidth = 0;
        let isAnimating = false;
        let isLocked = false; 
        let animationPath = []; 
        let currentPathIndex = 0; 
        let animX = 0, animY = 0; 
        let revealed = []; 
        let startChecked = []; 

        function toggleMode(mode) {
            if (mode === 'count') {
                document.getElementById('input-mode-count').classList.remove('hidden');
                document.getElementById('input-mode-custom').classList.add('hidden');
            } else {
                document.getElementById('input-mode-count').classList.add('hidden');
                document.getElementById('input-mode-custom').classList.remove('hidden');
            }
        }

        function shuffleInput() {
            const ta = document.getElementById('result-options');
            if (!ta.value.trim()) return;
            let lines = ta.value.split('\n').map(s => s.trim()).filter(s => s !== '');
            for (let i = lines.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [lines[i], lines[j]] = [lines[j], lines[i]];
            }
            ta.value = lines.join('\n');
        }

        function initGame() {
            participants = parseInt(document.getElementById('num-participants').value);
            if (participants < 2) participants = 2;
            if (participants > 10) participants = 10;

            results = [];
            const mode = document.querySelector('input[name="resultMode"]:checked').value;

            if (mode === 'count') {
                const winCount = parseInt(document.getElementById('num-winners').value);
                for(let i=0; i<participants; i++) {
                    results.push(i < winCount ? "ã‚ãŸã‚Š" : "ã¯ãšã‚Œ");
                }
                for (let i = results.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [results[i], results[j]] = [results[j], results[i]];
                }
            } else {
                const raw = document.getElementById('result-options').value.split('\n').map(s => s.trim()).filter(s => s !== '');
                for (let i = 0; i < participants; i++) {
                    results.push(raw[i] || "");
                }
            }

            isLocked = false;
            document.getElementById('btn-undo').disabled = false;
            canvas.classList.remove('locked');

            document.getElementById('setup-area').classList.add('hidden');
            document.getElementById('game-area').classList.remove('hidden');

            const containerWidth = gameArea.clientWidth - 30; 
            const canvasWidth = Math.min(600, containerWidth);
            
            const calcHeight = window.innerHeight - 200;
            const canvasHeight = Math.min(800, Math.max(250, calcHeight));
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            if (canvasHeight < 500) {
                START_BTN_Y = 25; MARGIN_TOP = 50; MARGIN_BOTTOM = 50;
            } else {
                START_BTN_Y = 30; MARGIN_TOP = 60; MARGIN_BOTTOM = 60;
            }
            
            columnWidth = canvas.width / (participants + 1);
            generateNameInputs();
            resetLines();
        }

        function showSetup() {
            document.getElementById('setup-area').classList.remove('hidden');
            document.getElementById('game-area').classList.add('hidden');
        }

        function undoLine() {
            if (isLocked) return;
            if (horizontalLines.length > 0) {
                horizontalLines.pop();
                draw();
            }
        }

        function resetLines() {
            horizontalLines = [];
            animationPath = []; 
            revealed = new Array(participants).fill(false);
            startChecked = new Array(participants).fill(false);
            isAnimating = false;
            isLocked = false;
            document.getElementById('btn-undo').disabled = false;
            canvas.classList.remove('locked');
            draw();
        }

        function generateNameInputs() {
            inputsLayer.innerHTML = '';
            const inputW = Math.min(50, Math.floor(columnWidth - 6)); 

            for (let i = 0; i < participants; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'name-input';
                input.placeholder = "ãªã¾ãˆ";
                input.style.width = inputW + 'px';
                const x = (i + 1) * columnWidth;
                input.style.left = (x - (inputW / 2) - 2) + 'px'; 
                inputsLayer.appendChild(input);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.textAlign = 'center';
            
            for (let i = 0; i < participants; i++) {
                const x = (i + 1) * columnWidth;

                // --- ãƒã‚±ãƒƒãƒˆæå†™ ---
                const ticketColor = '#007bff';
                const textColor = 'white';
                const fullWidth = 40;
                const stubWidth = 12;
                const mainWidth = fullWidth - stubWidth;
                const ticketHeight = 26;
                const ticketX = x - fullWidth / 2;
                const ticketY = START_BTN_Y - ticketHeight / 2;
                const notch = 3; 

                ctx.save();
                ctx.shadowColor = 'rgba(0,0,0,0.15)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetY = 2;

                ctx.fillStyle = ticketColor;
                ctx.beginPath();

                if (startChecked[i]) {
                    const mainX = ticketX + stubWidth;
                    ctx.moveTo(mainX, ticketY);
                    ctx.lineTo(mainX + mainWidth, ticketY);
                    ctx.lineTo(mainX + mainWidth, ticketY + ticketHeight / 2 - notch);
                    ctx.lineTo(mainX + mainWidth - notch, ticketY + ticketHeight / 2);
                    ctx.lineTo(mainX + mainWidth, ticketY + ticketHeight / 2 + notch);
                    ctx.lineTo(mainX + mainWidth, ticketY + ticketHeight);
                    ctx.lineTo(mainX, ticketY + ticketHeight);
                    ctx.closePath();
                    
                } else {
                    
                    ctx.moveTo(ticketX, ticketY);
                    ctx.lineTo(ticketX + fullWidth, ticketY);
                    ctx.lineTo(ticketX + fullWidth, ticketY + ticketHeight / 2 - notch);
                    ctx.lineTo(ticketX + fullWidth - notch, ticketY + ticketHeight / 2);
                    ctx.lineTo(ticketX + fullWidth, ticketY + ticketHeight / 2 + notch);
                    ctx.lineTo(ticketX + fullWidth, ticketY + ticketHeight);
                    ctx.lineTo(ticketX, ticketY + ticketHeight);
                    ctx.lineTo(ticketX, ticketY + ticketHeight / 2 + notch);
                    ctx.lineTo(ticketX + notch, ticketY + ticketHeight / 2);
                    ctx.lineTo(ticketX, ticketY + ticketHeight / 2 - notch);
                    ctx.closePath();
                }
                ctx.fill();
                ctx.restore();

                if (!startChecked[i]) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3, 2]);
                    ctx.moveTo(ticketX + stubWidth, ticketY);
                    ctx.lineTo(ticketX + stubWidth, ticketY + ticketHeight);
                    ctx.stroke();
                    ctx.setLineDash([]); 
                }

                ctx.fillStyle = textColor;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                if(startChecked[i]) {
                    ctx.fillText(i + 1, ticketX + stubWidth + mainWidth / 2, START_BTN_Y + 2);
                } else {
                    ctx.fillText(i + 1, x + 6, START_BTN_Y + 2);
                }

                ctx.strokeStyle = '#333'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(x, MARGIN_TOP); ctx.lineTo(x, canvas.height - MARGIN_BOTTOM); ctx.stroke();

                const boxW = Math.min(50, columnWidth - 6);
                const boxX = x - (boxW / 2);
                const boxY = canvas.height - (MARGIN_BOTTOM - 10);
                
                if (revealed[i]) {
                    if (results[i]) {
                        ctx.fillStyle = '#333'; ctx.font = 'bold 14px Arial';
                        if (results[i].length > 4 || columnWidth < 40) ctx.font = 'bold 10px Arial';
                        ctx.fillText(results[i], x, boxY + 20);
                    }
                } else {
                    ctx.fillStyle = 'black'; ctx.fillRect(boxX, boxY, boxW, 40);
                }
            }

            ctx.lineWidth = 3; ctx.strokeStyle = '#333';
            horizontalLines.forEach(l => {
                const x1 = (l.col + 1) * columnWidth, x2 = (l.col + 2) * columnWidth;
                ctx.beginPath(); ctx.moveTo(x1, l.y); ctx.lineTo(x2, l.y); ctx.stroke();
            });

            if (animationPath.length > 0) {
                ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(animationPath[0].x, animationPath[0].y);
                const limit = isAnimating ? currentPathIndex : animationPath.length - 1;
                for(let k=1; k <= limit; k++) ctx.lineTo(animationPath[k].x, animationPath[k].y);
                if (isAnimating) ctx.lineTo(animX, animY);
                ctx.stroke();
            }
        }

        canvas.addEventListener('mousedown', handleClick);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            canvas.dispatchEvent(new MouseEvent("mousedown", { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }));
        }, {passive: false});

        function handleClick(e) {
            if (isAnimating) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (y < MARGIN_TOP) {
                if (y > START_BTN_Y - 20) { 
                    for (let i = 0; i < participants; i++) {
                        if (Math.abs(x - (i + 1) * columnWidth) < 30) {
                            startAnimation(i); 
                            return;
                        }
                    }
                }
                return;
            }
            
            if (isLocked) return;
            if (y > MARGIN_TOP && y < canvas.height - MARGIN_BOTTOM) {
                const col = Math.floor(x / columnWidth) - 1;
                if (col >= 0 && col < participants - 1) {
                    if (!horizontalLines.some(l => l.col === col && Math.abs(l.y - y) < 15)) {
                        horizontalLines.push({ col: col, y: y });
                        draw();
                    }
                }
            }
        }

        function startAnimation(startIdx) {
            if (!isLocked) {
                isLocked = true;
                document.getElementById('btn-undo').disabled = true;
                canvas.classList.add('locked');
            }

            startChecked[startIdx] = true;
            
            animationPath = [];
            let cCol = startIdx, cY = MARGIN_TOP;
            animationPath.push({x: (cCol + 1) * columnWidth, y: cY});

            for(let i=0; i<2000; i++) {
                let next = horizontalLines
                    .filter(l => l.y > cY && (l.col === cCol || l.col === cCol - 1))
                    .sort((a,b) => a.y - b.y)[0];
                if (!next) {
                    cY = canvas.height - MARGIN_BOTTOM;
                    animationPath.push({x: (cCol + 1) * columnWidth, y: cY});
                    break;
                }
                cY = next.y;
                animationPath.push({x: (cCol + 1) * columnWidth, y: cY});
                cCol = (next.col === cCol) ? cCol + 1 : cCol - 1;
                animationPath.push({x: (cCol + 1) * columnWidth, y: cY});
            }
            isAnimating = true; currentPathIndex = 0;
            animX = animationPath[0].x; animY = animationPath[0].y;
            requestAnimationFrame(animateFrame);
        }

        function animateFrame() {
            const target = animationPath[currentPathIndex + 1];
            if (!target) {
                isAnimating = false;
                const finalCol = Math.round(animationPath[animationPath.length - 1].x / columnWidth) - 1;
                revealed[finalCol] = true;
                draw();
                return;
            }
            const speed = 6;
            if (animX < target.x) animX = Math.min(animX + speed, target.x);
            else if (animX > target.x) animX = Math.max(animX - speed, target.x);
            if (animY < target.y) animY = Math.min(animY + speed, target.y);
            if (animX === target.x && animY === target.y) currentPathIndex++;
            draw();
            if(isAnimating) requestAnimationFrame(animateFrame);
        }
    </script>
</body>
</html>
