<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã‚ã¿ã ãã˜ã‚¢ãƒ—ãƒª</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 fill=%22%23007bff%22 rx=%2212%22/><path d=%22M18 12v40M32 12v40M46 12v40M18 24h14M32 36h14M18 48h14%22 stroke=%22white%22 stroke-width=%224%22 stroke-linecap=%22round%22/></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 fill=%22%23007bff%22 rx=%2212%22/><path d=%22M18 12v40M32 12v40M46 12v40M18 24h14M32 36h14M18 48h14%22 stroke=%22white%22 stroke-width=%224%22 stroke-linecap=%22round%22/></svg>">

    <style>
        body { 
            font-family: "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif; 
            text-align: center; 
            background-color: #fdfdfd; 
            color: #333; 
            margin: 0; 
            padding: 10px; 
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden; /* å…¨ä½“ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ */
        }
        h1 { margin: 5px 0 10px 0; font-size: 20px; font-weight: bold; }
        
        #setup-area, #game-area { 
            margin: 0 auto; width: 100%; max-width: 600px; 
            background: white; padding: 15px; border-radius: 12px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); border: 1px solid #eee; 
            box-sizing: border-box; 
            display: flex; flex-direction: column; /* ç¸¦ä¸¦ã³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
            max-height: 95vh; /* ç”»é¢å†…ã«åã‚ã‚‹ */
        }
        .hidden { display: none !important; }
        
        /* è¨­å®šç”»é¢ */
        #setup-area { overflow-y: auto; } /* è¨­å®šç”»é¢ã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯ */

        label.section-title { font-weight: bold; display: block; margin-top: 20px; text-align: left; margin-left: 2%; font-size: 15px; }
        label.section-title:first-child { margin-top: 0; }
        .small-size { font-size: 0.85em; font-weight: normal; color: #666; }

        label.radio-option { display: block; font-weight: normal; margin-bottom: 8px; cursor: pointer; font-size: 14px; }
        @media (min-width: 400px) {
            label.radio-option { display: inline-block; margin-right: 15px; margin-bottom: 0; }
        }

        input[type="number"], select { padding: 8px; width: 80px; text-align: center; font-size: 16px; border: 1px solid #ccc; border-radius: 6px; background-color: #fff; }
        textarea { width: 95%; height: 80px; padding: 10px; margin: 5px 0; border: 1px solid #ccc; border-radius: 6px; font-size: 15px; resize: vertical; }
        
        /* ãƒœã‚¿ãƒ³å…±é€š */
        button { 
            padding: 10px; background-color: #333; color: white; border: none; border-radius: 6px; 
            cursor: pointer; font-size: 14px; font-weight: bold; transition: opacity 0.2s;
            min-height: 44px; 
        }
        button:hover { opacity: 0.8; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 1; }
        
        button.shuffle-btn { background-color: #ff9800; font-size: 13px; padding: 6px 12px; min-height: 35px; margin-top: 5px; } 
        button.secondary { background-color: #999; }
        
        #btn-lock { background-color: #28a745; }
        #btn-lock.locked { background-color: #6c757d; cursor: default; opacity: 0.8; }
        
        /* ä¸‹éƒ¨ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ï¼ˆ1è¡Œé…ç½®ï¼‰ */
        .button-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            margin-top: 10px;
            flex-shrink: 0; /* ç¸®å°ã•ã›ãªã„ */
        }
        .button-row button {
            flex: 1; /* ç­‰å¹… */
            padding: 0 5px;
            font-size: 13px; /* ã‚¹ãƒãƒ›ã§æŠ˜ã‚Šè¿”ã•ãªã„ã‚ˆã†å°‘ã—å°ã•ã */
            white-space: nowrap;
        }

        /* ãƒ’ãƒ³ãƒˆ */
        .hint-container {
            background: #f8f9fa; padding: 10px; border-radius: 8px; 
            margin-bottom: 5px; text-align: left; flex-shrink: 0;
        }
        .hint-item { display: flex; align-items: center; font-size: 12px; color: #555; margin-bottom: 3px; line-height: 1.3; }
        .hint-icon { font-size: 14px; margin-right: 6px; min-width: 18px; text-align: center; }

        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ */
        #canvas-container { 
            position: relative; 
            margin: 25px auto 5px auto; 
            width: 100%; 
            flex-grow: 1; /* æ®‹ã‚Šã®é«˜ã•ã‚’åŸ‹ã‚ã‚‹ */
            display: flex;
            align-items: flex-start; /* ä¸Šå¯„ã› */
            justify-content: center;
            overflow: hidden;
        }
        canvas { 
            touch-action: none; cursor: pointer; background: #fff; 
            display: block; width: 100%;
        }
        canvas.locked { cursor: default; }

        .name-input {
            position: absolute; 
            top: -22px; 
            padding: 2px; font-size: 11px; 
            text-align: center; border: 1px solid #ccc; border-radius: 4px; background: #fff;
            height: 20px; z-index: 10;
        }
        .name-input::placeholder { color: #ccc; }
        
        .setup-indent { text-align: left; margin-left: 2%; }
        .note-text { color:#666; display:inline-block; margin-top:5px; text-align:left; line-height: 1.4; font-size: 0.85em; }
    </style>
</head>
<body>

    <h1>ã‚ã¿ã ãã˜</h1>

    <div id="setup-area">
        <label class="section-title">å‚åŠ äººæ•° <span class="small-size">(2ã€œ10äºº)</span></label>
        <div class="setup-indent" style="margin-top: 5px;">
            <select id="num-participants" onchange="updateWinnersOptions()">
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4" selected>4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
            </select> äºº
        </div>

        <label class="section-title">çµæœ</label>
        <div class="setup-indent" style="margin-top: 10px;">
            <label class="radio-option">
                <input type="radio" name="resultMode" value="count" checked onclick="toggleMode('count')">
                ã‚ãŸã‚Šã®æ•°ã‚’é¸ã¶
            </label>
            <label class="radio-option">
                <input type="radio" name="resultMode" value="custom" onclick="toggleMode('custom')">
                ã‚«ã‚¹ã‚¿ãƒ ï¼ˆè‡ªç”±å…¥åŠ›ï¼‰
            </label>
        </div>

        <div id="input-mode-count" class="setup-indent">
            <br>ã‚ãŸã‚Šã®æ•°: 
            <select id="num-winners">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
            </select> æœ¬<br>
            <small class="note-text">â€»æ®‹ã‚Šã¯è‡ªå‹•çš„ã«ã€Œã¯ãšã‚Œã€ã«ãªã‚Šã¾ã™</small>
        </div>

        <div id="input-mode-custom" class="hidden setup-indent">
            <textarea id="result-options" placeholder="ã‚ãŸã‚Š&#13;&#10;ã¯ãšã‚Œ&#13;&#10;..." onfocus="this.placeholder=''" onblur="if(this.value=='')this.placeholder='ã‚ãŸã‚Š\nã¯ãšã‚Œ\n...'"></textarea><br>
            <button class="shuffle-btn" onclick="shuffleInput()">ğŸ”€ å†…å®¹ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«</button><br>
            <small class="note-text">
                â€»æ”¹è¡ŒåŒºåˆ‡ã‚Šã§å…¥åŠ›ã—ã¦ãã ã•ã„<br>
                â€»äººæ•°åˆ†ã«è¶³ã‚Šãªã„å ´åˆã¯ç©ºæ¬„ã«ãªã‚Šã¾ã™
            </small>
        </div>

        <br><br>
        <button onclick="initGame()" style="width: 100%; max-width: 300px; background-color: #007bff;">ä½œæˆã™ã‚‹</button>
    </div>

    <div id="game-area" class="hidden">
        <div class="hint-container">
            <div class="hint-item"><span class="hint-icon">âœï¸</span><span>æ ã«<b>åå‰ã‚’å…¥åŠ›</b></span></div>
            <div class="hint-item"><span class="hint-icon">ğŸ‘†</span><span><b>ç·šã¨ç·šã®é–“</b>ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ¨ªæ£’è¿½åŠ </span></div>
            <div class="hint-item"><span class="hint-icon">ğŸ”’</span><span>å…¨å“¡æ›¸ã„ãŸã‚‰<b>ãƒ­ãƒƒã‚¯</b></span></div>
            <div class="hint-item"><span class="hint-icon">ğŸ”¢</span><span><b>ä¸¸</b>ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ</span></div>
        </div>
        
        <div id="canvas-container">
            <div id="name-inputs-layer"></div>
            <canvas id="amidaCanvas"></canvas>
        </div>
        
        <div class="button-row">
            <button id="btn-lock" onclick="toggleLock()">ğŸ”“ æ¨ªç·šã‚’ãƒ­ãƒƒã‚¯</button>
            <button id="btn-undo" class="secondary" onclick="undoLine()">1ã¤æˆ»ã‚‹</button>
            <button class="secondary" onclick="showSetup()">ã‚„ã‚Šç›´ã™</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('amidaCanvas');
        const ctx = canvas.getContext('2d');
        const inputsLayer = document.getElementById('name-inputs-layer');
        const gameArea = document.getElementById('game-area');
        
        let MARGIN_TOP = 60;
        let START_BTN_Y = 25; 
        let MARGIN_BOTTOM = 60;
        
        let participants = 4;
        let results = [];
        let horizontalLines = []; 
        let columnWidth = 0;
        let isAnimating = false;
        let isLocked = false; 
        let animationPath = []; 
        let currentPathIndex = 0; 
        let animX = 0, animY = 0; 
        let revealed = []; 
        let startChecked = []; 

        window.addEventListener('DOMContentLoaded', () => {
            updateWinnersOptions();
        });

        function updateWinnersOptions() {
            const pSelect = document.getElementById('num-participants');
            const wSelect = document.getElementById('num-winners');
            const currentP = parseInt(pSelect.value);
            const currentW = parseInt(wSelect.value);

            wSelect.innerHTML = '';
            for (let i = 1; i <= currentP; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.text = i;
                wSelect.appendChild(option);
            }

            if (currentW <= currentP && currentW >= 1) {
                wSelect.value = currentW;
            } else {
                wSelect.value = 1;
            }
        }

        function toggleMode(mode) {
            if (mode === 'count') {
                document.getElementById('input-mode-count').classList.remove('hidden');
                document.getElementById('input-mode-custom').classList.add('hidden');
            } else {
                document.getElementById('input-mode-count').classList.add('hidden');
                document.getElementById('input-mode-custom').classList.remove('hidden');
            }
        }

        function shuffleInput() {
            const ta = document.getElementById('result-options');
            if (!ta.value.trim()) return;
            let lines = ta.value.split('\n').map(s => s.trim()).filter(s => s !== '');
            for (let i = lines.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [lines[i], lines[j]] = [lines[j], lines[i]];
            }
            ta.value = lines.join('\n');
        }

        function initGame() {
            participants = parseInt(document.getElementById('num-participants').value);
            
            results = [];
            const mode = document.querySelector('input[name="resultMode"]:checked').value;

            if (mode === 'count') {
                const winCount = parseInt(document.getElementById('num-winners').value);
                for(let i=0; i<participants; i++) {
                    results.push(i < winCount ? "ã‚ãŸã‚Š" : "ã¯ãšã‚Œ");
                }
                for (let i = results.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [results[i], results[j]] = [results[j], results[i]];
                }
            } else {
                const raw = document.getElementById('result-options').value.split('\n').map(s => s.trim()).filter(s => s !== '');
                for (let i = 0; i < participants; i++) {
                    results.push(raw[i] || "");
                }
            }

            isLocked = false;
            updateLockUI();
            document.getElementById('setup-area').classList.add('hidden');
            document.getElementById('game-area').classList.remove('hidden');

            // ç”»é¢é«˜ã•ã‚’è¨ˆç®—ã—ã¦ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’æ±ºå®š
            // ãƒ˜ãƒƒãƒ€ãƒ¼ + ãƒ’ãƒ³ãƒˆ + ãƒœã‚¿ãƒ³ + ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ç­‰ã®é«˜ã• = ç´„250px
            // containerã®å¹…ã«åˆã‚ã›ã‚‹
            const containerWidth = gameArea.clientWidth - 30; 
            const canvasWidth = Math.min(600, containerWidth);
            
            // åˆ©ç”¨å¯èƒ½ãªé«˜ã•ã‚’è¨ˆç®—
            const uiHeight = 250; 
            const availableHeight = window.innerHeight - uiHeight;
            const canvasHeight = Math.min(800, Math.max(250, availableHeight));
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            if (canvasHeight < 400) {
                START_BTN_Y = 25; MARGIN_TOP = 50; MARGIN_BOTTOM = 50;
            } else {
                START_BTN_Y = 30; MARGIN_TOP = 60; MARGIN_BOTTOM = 60;
            }
            
            columnWidth = canvas.width / (participants + 1);
            generateNameInputs();
            resetLines();
        }

        function showSetup() {
            document.getElementById('setup-area').classList.remove('hidden');
            document.getElementById('game-area').classList.add('hidden');
        }

        function toggleLock() {
            if (isLocked) return; 
            isLocked = true;
            updateLockUI();
        }

        function updateLockUI() {
            const btnLock = document.getElementById('btn-lock');
            const btnUndo = document.getElementById('btn-undo');
            
            if (isLocked) {
                btnLock.innerText = "ğŸ”’ ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸ";
                btnLock.classList.add('locked');
                btnLock.disabled = true; 
                btnUndo.disabled = true;
                canvas.classList.add('locked');
            } else {
                btnLock.innerText = "ğŸ”“ æ¨ªç·šã‚’ãƒ­ãƒƒã‚¯";
                btnLock.classList.remove('locked');
                btnLock.disabled = false;
                btnUndo.disabled = false;
                canvas.classList.remove('locked');
            }
        }

        function undoLine() {
            if (isLocked) return;
            if (horizontalLines.length > 0) {
                horizontalLines.pop();
                draw();
            }
        }

        function resetLines() {
            horizontalLines = [];
            animationPath = []; 
            revealed = new Array(participants).fill(false);
            startChecked = new Array(participants).fill(false);
            isAnimating = false;
            draw();
        }

        function generateNameInputs() {
            inputsLayer.innerHTML = '';
            const inputW = Math.min(50, Math.floor(columnWidth - 6)); 

            for (let i = 0; i < participants; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'name-input';
                input.placeholder = "ãªã¾ãˆ";
                input.style.width = inputW + 'px';
                const x = (i + 1) * columnWidth;
                input.style.left = (x - (inputW / 2) - 2) + 'px'; 
                
                inputsLayer.appendChild(input);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.textAlign = 'center';
            
            for (let i = 0; i < participants; i++) {
                const x = (i + 1) * columnWidth;
                
                ctx.beginPath();
                ctx.arc(x, START_BTN_Y, 14, 0, Math.PI * 2);
                
                if (startChecked[i]) {
                    ctx.fillStyle = '#f2f2f2'; 
                    ctx.fill();
                    ctx.strokeStyle = '#d0d0d0'; 
                    ctx.lineWidth = 2; 
                    ctx.stroke();
                    ctx.fillStyle = '#ccc';
                } else {
                    ctx.fillStyle = 'white'; 
                    ctx.fill();
                    ctx.strokeStyle = '#333'; 
                    ctx.lineWidth = 2; 
                    ctx.stroke();
                    ctx.fillStyle = '#333';
                }
                
                ctx.font = 'bold 14px Arial'; 
                ctx.textBaseline = 'middle';
                ctx.fillText(i + 1, x, START_BTN_Y + 1);

                ctx.strokeStyle = '#333'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(x, MARGIN_TOP); ctx.lineTo(x, canvas.height - MARGIN_BOTTOM); ctx.stroke();

                const boxW = Math.min(50, columnWidth - 6);
                const boxX = x - (boxW / 2);
                const boxY = canvas.height - (MARGIN_BOTTOM - 10);
                
                if (revealed[i]) {
                    if (results[i]) {
                        ctx.fillStyle = '#333'; ctx.font = 'bold 14px Arial';
                        if (results[i].length > 4 || columnWidth < 40) ctx.font = 'bold 10px Arial';
                        ctx.fillText(results[i], x, boxY + 20);
                    }
                } else {
                    ctx.fillStyle = 'black'; ctx.fillRect(boxX, boxY, boxW, 40);
                }
            }

            ctx.lineWidth = 3; ctx.strokeStyle = '#333';
            horizontalLines.forEach(l => {
                const x1 = (l.col + 1) * columnWidth, x2 = (l.col + 2) * columnWidth;
                ctx.beginPath(); ctx.moveTo(x1, l.y); ctx.lineTo(x2, l.y); ctx.stroke();
            });

            if (animationPath.length > 0) {
                ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(animationPath[0].x, animationPath[0].y);
                const limit = isAnimating ? currentPathIndex : animationPath.length - 1;
                for(let k=1; k <= limit; k++) ctx.lineTo(animationPath[k].x, animationPath[k].y);
                if (isAnimating) ctx.lineTo(animX, animY);
                ctx.stroke();
            }
        }

        canvas.addEventListener('mousedown', handleClick);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            canvas.dispatchEvent(new MouseEvent("mousedown", { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }));
        }, {passive: false});

        function handleClick(e) {
            if (isAnimating) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (y < MARGIN_TOP) {
                if (y > START_BTN_Y - 20) { 
                    for (let i = 0; i < participants; i++) {
                        if (Math.abs(x - (i + 1) * columnWidth) < 30) {
                            startAnimation(i); 
                            return;
                        }
                    }
                }
                return;
            }
            
            if (isLocked) return;
            if (y > MARGIN_TOP && y < canvas.height - MARGIN_BOTTOM) {
                const col = Math.floor(x / columnWidth) - 1;
                if (col >= 0 && col < participants - 1) {
                    if (!horizontalLines.some(l => l.col === col && Math.abs(l.y - y) < 15)) {
                        horizontalLines.push({ col: col, y: y });
                        draw();
                    }
                }
            }
        }

        function startAnimation(startIdx) {
            startChecked[startIdx] = true;
            
            animationPath = [];
            let cCol = startIdx, cY = MARGIN_TOP;
            animationPath.push({x: (cCol + 1) * columnWidth, y: cY});

            for(let i=0; i<2000; i++) {
                let next = horizontalLines
                    .filter(l => l.y > cY && (l.col === cCol || l.col === cCol - 1))
                    .sort((a,b) => a.y - b.y)[0];
                if (!next) {
                    cY = canvas.height - MARGIN_BOTTOM;
                    animationPath.push({x: (cCol + 1) * columnWidth, y: cY});
                    break;
                }
                cY = next.y;
                animationPath.push({x: (cCol + 1) * columnWidth, y: cY});
                cCol = (next.col === cCol) ? cCol + 1 : cCol - 1;
                animationPath.push({x: (cCol + 1) * columnWidth, y: cY});
            }
            isAnimating = true; currentPathIndex = 0;
            animX = animationPath[0].x; animY = animationPath[0].y;
            requestAnimationFrame(animateFrame);
        }

        function animateFrame() {
            const target = animationPath[currentPathIndex + 1];
            if (!target) {
                isAnimating = false;
                const finalCol = Math.round(animationPath[animationPath.length - 1].x / columnWidth) - 1;
                revealed[finalCol] = true;
                draw();
                return;
            }
            const speed = 6;
            if (animX < target.x) animX = Math.min(animX + speed, target.x);
            else if (animX > target.x) animX = Math.max(animX - speed, target.x);
            if (animY < target.y) animY = Math.min(animY + speed, target.y);
            if (animX === target.x && animY === target.y) currentPathIndex++;
            draw();
            if(isAnimating) requestAnimationFrame(animateFrame);
        }
    </script>
</body>
</html>
